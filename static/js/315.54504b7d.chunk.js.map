{"version":3,"file":"static/js/315.54504b7d.chunk.js","mappings":"yBAiDA,SAASA,EAAcC,EAAeC,EAAeC,GACnD,IAAK,IAAIC,EAAIH,EAAQ,EAAGG,GAAKH,EAAQ,EAAGG,IACtC,IAAK,IAAIC,EAAIH,EAAQ,EAAGG,GAAKH,EAAQ,EAAGG,IAAK,CAAC,IAAD,EACpB,KAAf,OAAJF,QAAI,IAAJA,GAAA,UAAAA,EAAOC,UAAP,eAAYC,MACdF,EAAKF,GAAOC,GAAS,EACrBF,EAAcI,EAAGC,EAAGF,KCnD5BG,KAAKC,UAAY,YAAsC,IAAD,IAAlCC,KACZL,EDcD,SAAsBF,EAAeC,EAAeO,GAGzD,IAFA,IAAMC,EAAwB,GAErBN,EAAI,EAAGA,EAAIH,EAAOG,IAAK,CAC9BM,EAAUN,GAAK,GACf,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAOG,IACzBK,EAAUN,GAAGC,GAAKM,KAAKC,SAAWH,EAAc,EAAI,EAIxD,OAAOC,ECxBMG,CADuC,EAA1BC,EAA0B,EAAvBC,EAAuB,EAApBN,aAE1BO,ED0BD,SAAsBb,GAM3B,IALA,IAAIa,EAAQ,EACNC,EAAYC,KAAKC,MAAMD,KAAKE,UAAUjB,IACtCF,EAAQgB,EAAUI,OAClBnB,EAAQe,EAAU,GAAGI,OAElBjB,EAAI,EAAGA,EAAIH,EAAOG,IACzB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAOG,IACrBY,EAAUb,GAAGC,KACfW,IACAhB,EAAcI,EAAGC,EAAGY,IAK1B,OAAOD,ECzCOM,CAAanB,GAE3BG,KAAKiB,YAAY,CACfpB,KAAAA,EACAa,MAAAA,K","sources":["utils/grid-utils.tsx","grid-worker.ts"],"sourcesContent":["function getWindowDimensions(): {\n  innerWidth: number,\n  innerHeight: number,\n  headerHeight: number,\n  cellWidth: number,\n  cellHeight: number,\n  gridContainerBorder: number,\n} {\n  return {\n    innerWidth: window.innerWidth,\n    innerHeight: window.innerHeight,\n    headerHeight: window.innerWidth <= 480 ? 120 : 35,\n    cellWidth: 15,\n    cellHeight: 15,\n    gridContainerBorder: 4,\n  };\n}\n\nexport function generateGrid(gridX: number, gridY: number, probability: number): number[][] {\n  const gridItems: number[][] = [];\n\n  for (let i = 0; i < gridX; i++) {\n    gridItems[i] = [];\n    for (let j = 0; j < gridY; j++) {\n      gridItems[i][j] = Math.random() < probability ? 1 : 0;\n    }\n  }\n\n  return gridItems;\n}\n\nexport function countIslands(grid: number[][]): number {\n  let count = 0;\n  const gridClone = JSON.parse(JSON.stringify(grid));\n  const gridX = gridClone.length;\n  const gridY = gridClone[0].length;\n\n  for (let i = 0; i < gridX; i++) {\n    for (let j = 0; j < gridY; j++) {\n      if (gridClone[i][j]) {\n        count++;\n        markNeighbors(i, j, gridClone);\n      }\n    }\n  }\n\n  return count;\n}\n\nfunction markNeighbors(gridX: number, gridY: number, grid: number[][]) {\n  for (let i = gridX - 1; i <= gridX + 1; i++) {\n    for (let j = gridY - 1; j <= gridY + 1; j++) {\n      if (grid?.[i]?.[j] === 1) {\n        grid[gridX][gridY] = 0;\n        markNeighbors(i, j, grid);\n      }\n    }\n  }\n}\n\nexport function calculateVisibleDimensions({ gridSize }: { gridSize: { x: number, y: number } }): { x: number, y: number } {\n  const { innerWidth, innerHeight, headerHeight, cellHeight, cellWidth, gridContainerBorder } = getWindowDimensions();\n  const requiredWidth = gridSize.x * cellWidth + gridContainerBorder;\n  const requiredHeight = gridSize.y * cellHeight + gridContainerBorder;\n\n  return {\n    x: innerWidth < requiredWidth ? innerWidth : requiredWidth + gridContainerBorder,\n    y: innerHeight - headerHeight < requiredHeight ? innerHeight - headerHeight : requiredHeight,\n  };\n}\n\n\nexport function getGridSizeToFitScreen(): { x: number, y: number } {\n  const { innerWidth, innerHeight, headerHeight, cellWidth } = getWindowDimensions();\n  return { x: Math.floor(innerWidth / cellWidth), y: Math.floor((innerHeight - headerHeight) / cellWidth) };\n}\n\n","import { countIslands, generateGrid } from './utils';\n\n// eslint-disable-next-line no-restricted-globals\nself.onmessage = ({ data: { x, y, probability } }) => {\n  const grid = generateGrid(x, y, probability);\n  const count = countIslands(grid);\n  // eslint-disable-next-line no-restricted-globals\n  self.postMessage({\n    grid,\n    count\n  });\n};\n\nexport {}\n"],"names":["markNeighbors","gridX","gridY","grid","i","j","self","onmessage","data","probability","gridItems","Math","random","generateGrid","x","y","count","gridClone","JSON","parse","stringify","length","countIslands","postMessage"],"sourceRoot":""}